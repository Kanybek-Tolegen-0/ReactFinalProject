{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.defaultConfig = void 0;\n\nvar _utils = require(\"./utils\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defaultConfig = {\n  color: '#dee4fd',\n  radius: [0.5, 3.0],\n  speed: [1.0, 3.0],\n  wind: [-0.5, 2.0],\n  changeFrequency: 200\n};\nexports.defaultConfig = defaultConfig;\n/** An individual snowflake that will update it's location every call to `draw` */\n\nvar Snowflake = /*#__PURE__*/function () {\n  function Snowflake(_canvas) {\n    var _this = this;\n\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Snowflake);\n\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"params\", void 0);\n\n    _defineProperty(this, \"framesSinceLastUpdate\", void 0);\n\n    _defineProperty(this, \"draw\", function (canvas, inputCtx) {\n      var ctx = inputCtx || canvas.getContext('2d');\n\n      if (ctx) {\n        ctx.beginPath();\n        ctx.arc(_this.params.x, _this.params.y, _this.params.radius, 0, 2 * Math.PI);\n        ctx.fillStyle = _this.fullConfig.color;\n        ctx.closePath();\n        ctx.fill();\n      }\n    });\n\n    _defineProperty(this, \"translate\", function (canvas) {\n      var framesPassed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var _this$params = _this.params,\n          x = _this$params.x,\n          y = _this$params.y,\n          wind = _this$params.wind,\n          speed = _this$params.speed,\n          nextWind = _this$params.nextWind,\n          nextSpeed = _this$params.nextSpeed; // Update current location, wrapping around if going off the canvas\n\n      _this.params.x = (x + wind * framesPassed) % canvas.offsetWidth;\n      _this.params.y = (y + speed * framesPassed) % canvas.offsetHeight; // Update the wind and speed towards the desired values\n\n      _this.params.speed = (0, _utils.lerp)(speed, nextSpeed, 0.01);\n      _this.params.wind = (0, _utils.lerp)(wind, nextWind, 0.01);\n\n      if (_this.framesSinceLastUpdate++ > _this.fullConfig.changeFrequency) {\n        _this.updateTargetParams();\n\n        _this.framesSinceLastUpdate = 0;\n      }\n    });\n\n    _defineProperty(this, \"updateTargetParams\", function () {\n      _this.params.nextSpeed = _utils.random.apply(void 0, _toConsumableArray(_this.fullConfig.speed));\n      _this.params.nextWind = _utils.random.apply(void 0, _toConsumableArray(_this.fullConfig.wind));\n    });\n\n    _defineProperty(this, \"update\", function (canvas, framesPassed) {\n      _this.translate(canvas, framesPassed);\n    }); // Set custom config\n\n\n    this.config = config; // Setting initial parameters\n\n    var _this$fullConfig = this.fullConfig,\n        radius = _this$fullConfig.radius,\n        _wind = _this$fullConfig.wind,\n        _speed = _this$fullConfig.speed;\n    this.params = {\n      x: (0, _utils.random)(0, _canvas.offsetWidth),\n      y: (0, _utils.random)(-_canvas.offsetHeight, 0),\n      radius: _utils.random.apply(void 0, _toConsumableArray(radius)),\n      speed: _utils.random.apply(void 0, _toConsumableArray(_speed)),\n      wind: _utils.random.apply(void 0, _toConsumableArray(_wind)),\n      nextSpeed: _utils.random.apply(void 0, _toConsumableArray(_wind)),\n      nextWind: _utils.random.apply(void 0, _toConsumableArray(_speed))\n    };\n    this.framesSinceLastUpdate = 0;\n  }\n\n  _createClass(Snowflake, [{\n    key: \"fullConfig\",\n    get: function get() {\n      return _objectSpread(_objectSpread({}, defaultConfig), this.config);\n    }\n  }]);\n\n  return Snowflake;\n}();\n\nvar _default = Snowflake;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["C:\\Users\\ayaul\\OneDrive\\Документы\\ReactFinal\\ReactFinalProject\\node_modules\\react-snowfall\\src\\Snowflake.ts"],"names":["defaultConfig","color","radius","speed","wind","changeFrequency","Snowflake","config","x","canvas","y","random","nextSpeed","nextWind","ctx","inputCtx","Math","framesPassed"],"mappings":"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","sourcesContent":["import { lerp, random } from './utils'\r\n\r\nexport interface SnowflakeProps {\r\n  /** The color of the snowflake, can be any valid CSS color. */\r\n  color: string\r\n  /**\r\n   * The minimum and maximum radius of the snowflake, will be\r\n   * randomly selected within this range.\r\n   * \r\n   * The default value is `[0.5, 3.0]`.\r\n   */\r\n  radius: [minimumRadius: number, maximumRadius: number]\r\n  /**\r\n   * The minimum and maximum speed of the snowflake.\r\n   * \r\n   * The speed determines how quickly the snowflake moves\r\n   * along the y axis (vertical speed).\r\n   * \r\n   * The values will be randomly selected within this range.\r\n   * \r\n   * The default value is `[1.0, 3.0]`.\r\n   */\r\n  speed: [minimumSpeed: number, maximumSpeed: number]\r\n  /**\r\n   * The minimum and maximum wind of the snowflake.\r\n   * \r\n   * The wind determines how quickly the snowflake moves\r\n   * along the x axis (horizontal speed).\r\n   * \r\n   * The values will be randomly selected within this range.\r\n   * \r\n   * The default value is `[-0.5, 2.0]`.\r\n   */\r\n  wind: [minimumWind: number, maximumWind: number]\r\n  /** \r\n   * The frequency in frames that the wind and speed values\r\n   * will update.\r\n   * \r\n   * The default value is 200.\r\n   */\r\n  changeFrequency: number\r\n}\r\n\r\nexport type SnowflakeConfig = Partial<SnowflakeProps>\r\n\r\nexport const defaultConfig: SnowflakeProps = {\r\n  color: '#dee4fd',\r\n  radius: [0.5, 3.0],\r\n  speed: [1.0, 3.0],\r\n  wind: [-0.5, 2.0],\r\n  changeFrequency: 200,\r\n}\r\n\r\ninterface SnowflakeParams {\r\n  x: number\r\n  y: number\r\n  radius: number\r\n  speed: number\r\n  wind: number\r\n  nextSpeed: number\r\n  nextWind: number\r\n}\r\n\r\n/** An individual snowflake that will update it's location every call to `draw` */\r\nclass Snowflake {\r\n  public config: SnowflakeConfig\r\n  private params: SnowflakeParams\r\n  private framesSinceLastUpdate: number\r\n\r\n  public constructor(canvas: HTMLCanvasElement, config: SnowflakeConfig = {}) {\r\n    // Set custom config\r\n    this.config = config\r\n\r\n    // Setting initial parameters\r\n    const { radius, wind, speed } = this.fullConfig\r\n\r\n    this.params = {\r\n      x: random(0, canvas.offsetWidth),\r\n      y: random(-canvas.offsetHeight, 0),\r\n      radius: random(...radius),\r\n      speed: random(...speed),\r\n      wind: random(...wind),\r\n      nextSpeed: random(...wind),\r\n      nextWind: random(...speed),\r\n    }\r\n\r\n    this.framesSinceLastUpdate = 0\r\n  }\r\n\r\n  private get fullConfig() {\r\n    return {\r\n      ...defaultConfig,\r\n      ...this.config,\r\n    }\r\n  }\r\n\r\n  public draw = (canvas: HTMLCanvasElement, inputCtx?: CanvasRenderingContext2D) => {\r\n    const ctx = inputCtx || canvas.getContext('2d')\r\n    if (ctx) {\r\n      ctx.beginPath()\r\n      ctx.arc(this.params.x, this.params.y, this.params.radius, 0, 2 * Math.PI)\r\n      ctx.fillStyle = this.fullConfig.color\r\n      ctx.closePath()\r\n      ctx.fill()\r\n    }\r\n  }\r\n\r\n  private translate = (canvas: HTMLCanvasElement, framesPassed: number = 1) => {\r\n    const { x, y, wind, speed, nextWind, nextSpeed } = this.params\r\n\r\n    // Update current location, wrapping around if going off the canvas\r\n    this.params.x = (x + wind * framesPassed) % canvas.offsetWidth\r\n    this.params.y = (y + speed * framesPassed) % canvas.offsetHeight\r\n\r\n    // Update the wind and speed towards the desired values\r\n    this.params.speed = lerp(speed, nextSpeed, 0.01)\r\n    this.params.wind = lerp(wind, nextWind, 0.01)\r\n\r\n    if (this.framesSinceLastUpdate++ > this.fullConfig.changeFrequency) {\r\n      this.updateTargetParams()\r\n      this.framesSinceLastUpdate = 0\r\n    }\r\n  }\r\n\r\n  private updateTargetParams = () => {\r\n    this.params.nextSpeed = random(...this.fullConfig.speed)\r\n    this.params.nextWind = random(...this.fullConfig.wind)\r\n  }\r\n\r\n  public update = (canvas: HTMLCanvasElement, framesPassed?: number) => {\r\n    this.translate(canvas, framesPassed)\r\n  }\r\n}\r\n\r\nexport default Snowflake\r\n"]},"metadata":{},"sourceType":"script"}